{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../src/helpers.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAEjC,MAAM,CAAC,MAAM,aAAa,GAAG,qBAAqB,CAAC;AAEnD,MAAM,UAAU,YAAY;IAC1B,OAAO,QAAQ,CAAC,KAAK,EAAE,CAAC,KAAK,EAAE,CAAC,SAAS,EAAE,CAAC;AAC9C,CAAC;AAGD,MAAM,UAAU,2BAA2B,CAAC,GAAW;IACrD,iCAAiC;IACjC,yGAAyG;IACzG,MAAM,YAAY,GAAG,GAAG,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC;IAEpD,IAAI,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;QAC3B,OAAO,YAAY,CAAC;KACrB;SAAM;QACL,MAAM,IAAI,KAAK,CACb,8GAA8G,CAC/G,CAAC;KACH;AACH,CAAC;AAED,MAAM,UAAU,SAAS,CACvB,IAAyB,EACzB,IAAyB;IAEzB,IAAI,IAAI,KAAK,IAAI,EAAE;QACjB,OAAO,IAAI,CAAC;KACb;IAED,IACE,OAAO,IAAI,KAAK,QAAQ;QACxB,IAAI,KAAK,IAAI;QACb,OAAO,IAAI,KAAK,QAAQ;QACxB,IAAI,KAAK,IAAI,EACb;QACA,OAAO,KAAK,CAAC;KACd;IAED,IAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC9B,IAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAE9B,IAAI,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,EAAE;QACjC,OAAO,KAAK,CAAC;KACd;IAED,KAAK,IAAI,GAAG,IAAI,KAAK,EAAE;QACrB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;YAC5D,OAAO,KAAK,CAAC;SACd;KACF;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,KAAK,CAAC,EAAU;IACpC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3D,CAAC;AAED,MAAM,UAAU,cAAc,CAAI,KAAoB;IACpD,OAAO,KAAK,KAAK,SAAS,CAAC;AAC7B,CAAC;AAED,qDAAqD;AACrD,MAAM,UAAU,yBAAyB,CACvC,GAAkB,EAClB,QAAgB,CAAC;IAEjB,OAAO,GAAG,CAAC,WAAW,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC;AACpD,CAAC;AAED,wDAAwD;AACxD,MAAM,UAAU,4BAA4B,CAC1C,GAAkB,EAClB,KAAa,EACb,UAAkB;IAElB,MAAM,aAAa,GAAG,GAAG,CAAC,WAAW,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC;IACzD,IAAI,aAAa,EAAE;QACjB,aAAa,CAAC,OAAO,GAAG,UAAU,CAAC;KACpC;AACH,CAAC","sourcesContent":["import { DateTime } from 'luxon';\nimport { OutputContext } from './@types';\nexport const redisKeyRegex = /^[a-zA-Z0-9:_\\.-]*$/;\n\nexport function getTimestamp() {\n  return DateTime.local().toUTC().toSeconds();\n}\n\ntype SanitizeRedisKey = string;\nexport function sanitizeAndValidateRedisKey(key: string): SanitizeRedisKey {\n  // Regular expression to test key\n  // This expression will allow alphanumeric characters (a-z, A-Z, 0-9) and the specified symbols (: . - _)\n  const sanitizedKey = key.replace(/[\\n\\r\\t\\b]/g, '');\n\n  if (redisKeyRegex.test(key)) {\n    return sanitizedKey;\n  } else {\n    throw new Error(\n      'Invalid Redis key. Allowed only alphanumeric characters (a-z, A-Z, 0-9) and the specified symbols (: . - _)`',\n    );\n  }\n}\n\nexport function deepEqual(\n  obj1: Record<string, any>,\n  obj2: Record<string, any>,\n) {\n  if (obj1 === obj2) {\n    return true;\n  }\n\n  if (\n    typeof obj1 !== 'object' ||\n    obj1 === null ||\n    typeof obj2 !== 'object' ||\n    obj2 === null\n  ) {\n    return false;\n  }\n\n  let keys1 = Object.keys(obj1);\n  let keys2 = Object.keys(obj2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (let key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport async function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function isNotUndefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n// A function to get the content of a choice by index\nexport function getContentOfChoiceByIndex(\n  ctx: OutputContext,\n  index: number = 0,\n): string | undefined {\n  return ctx.llmResponse?.candidates[index].content;\n}\n\n// A function to modify the content of a choice by index\nexport function modifyContentOfChoiceByIndex(\n  ctx: OutputContext,\n  index: number,\n  newContent: string,\n): void {\n  const choiceMessage = ctx.llmResponse?.candidates[index];\n  if (choiceMessage) {\n    choiceMessage.content = newContent;\n  }\n}\n"]}