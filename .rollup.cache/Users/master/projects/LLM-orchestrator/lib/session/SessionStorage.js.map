{"version":3,"file":"SessionStorage.js","sourceRoot":"","sources":["../../src/session/SessionStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import { Redis, Cluster } from 'ioredis';\nimport { SessionProps } from '../@types';\nimport { deepEqual, getTimestamp } from '../helpers';\nimport { Session } from './Session';\nimport { ChatHistory } from './ChatHistory';\nimport { Message } from './Message';\nimport { getLogger } from './../Logger';\n\nconst l = getLogger('SessionStorage');\n\nexport class SessionStorage {\n  constructor(\n    private readonly client: Redis | Cluster,\n    private readonly sessionTtl: number,\n    private readonly appName: string,\n  ) {\n    l.info('SessionStorage initialization...');\n  }\n\n  private getChatCompletionSessionKey(\n    sessionId: string,\n    systemMessageName: string,\n  ): string {\n    return `app:${this.appName}:api_type:chat_completion:function:session_storage:session:${sessionId}:system_message:${systemMessageName}`;\n  }\n\n  async isExists(\n    sessionId: string,\n    systemMessageName: string,\n  ): Promise<boolean> {\n    const sessionKey = this.getChatCompletionSessionKey(\n      sessionId,\n      systemMessageName,\n    );\n    l.info(`Check session exists by key: ${sessionKey}`);\n    const result = await this.client.exists(sessionKey);\n    return result === 1;\n  }\n\n  async createSession(\n    sessionId: string,\n    systemMessageName: string,\n    systemMessage: string,\n    model: string,\n    modelPreset: SessionProps['modelPreset'],\n    examples: SessionProps['examples'],\n    messages: Message[],\n  ): Promise<void> {\n    const sessionKey = this.getChatCompletionSessionKey(\n      sessionId,\n      systemMessageName,\n    );\n    l.info(`Create session by key: ${sessionKey}`);\n    const timestamp = getTimestamp();\n    const [userMessage] = messages;\n\n    if (!systemMessage && !userMessage) {\n      throw new Error(\"Can't create session without system and user messages\");\n    }\n\n    const session = new Session(this, {\n      sessionId,\n      systemMessageName,\n      systemMessage,\n      model,\n      modelPreset,\n      messages: messages as ChatHistory,\n      examples,\n      lastMessageByRole: {\n        user: userMessage,\n        assistant: null,\n      },\n      handlersCount: {},\n      ctx: {},\n      messageAccumulator: [],\n      createdAt: timestamp,\n      updatedAt: timestamp,\n      lastError: null,\n    });\n\n    await this.client.set(\n      sessionKey,\n      JSON.stringify(session),\n      'EX',\n      this.sessionTtl,\n    );\n  }\n\n  async appendMessages(\n    sessionId: string,\n    systemMessageName: string,\n    newMessages: Message[],\n  ): Promise<void> {\n    try {\n      l.info(\n        `Append messages to session ${sessionId}, systemMessageName: ${systemMessageName}`,\n      );\n\n      const session = await this.getSession(sessionId, systemMessageName);\n\n      newMessages.forEach((newMessage) => {\n        session.messages.push(newMessage);\n\n        session.lastMessageByRole[newMessage.author] = newMessage;\n      });\n      session.updatedAt = getTimestamp();\n\n      const sessionKey = this.getChatCompletionSessionKey(\n        sessionId,\n        systemMessageName,\n      );\n\n      if (!session.messageAccumulator) {\n        session.messageAccumulator = [];\n      }\n\n      await this.client.set(\n        sessionKey,\n        JSON.stringify(session),\n        'EX',\n        this.sessionTtl,\n      );\n    } catch (error) {\n      l.error(error);\n      throw error;\n    }\n  }\n\n  async appendMessagesToAccumulator(\n    sessionId: string,\n    systemMessageName: string,\n    newMessages: Message[],\n    session?: Session,\n  ): Promise<void> {\n    if (!session) {\n      session = await this.getSession(sessionId, systemMessageName);\n    }\n\n    if (!session.messageAccumulator) {\n      session.messageAccumulator = [];\n    }\n\n    session.messageAccumulator.push(...newMessages);\n\n    const sessionKey = this.getChatCompletionSessionKey(\n      sessionId,\n      systemMessageName,\n    );\n\n    await this.client.set(\n      sessionKey,\n      JSON.stringify(session),\n      'EX',\n      this.sessionTtl,\n    );\n  }\n\n  async deleteSession(\n    sessionId: string,\n    systemMessageName: string,\n  ): Promise<void> {\n    const sessionKey = this.getChatCompletionSessionKey(\n      sessionId,\n      systemMessageName,\n    );\n    l.info(`Delete session by key: ${sessionKey}`);\n\n    await this.client.del(sessionKey);\n  }\n\n  async deleteSessionsById(sessionId: string) {\n    l.info(`Delete sessions by id: ${sessionId}`);\n    const keys = await this.findKeysByPartialName(sessionId);\n    await this.client.del(keys);\n  }\n  private async findKeysByPartialName(partialKey: string) {\n    try {\n      l.info(`Find keys by partial name: ${partialKey}`);\n      return this.client.keys(`*${partialKey}*`);\n    } catch (error) {\n      l.error(error);\n      throw error;\n    }\n  }\n\n  async incrementHandlerCount(\n    sessionId: string,\n    systemMessageName: string,\n    handlerName: string,\n  ) {\n    l.info(\n      `Increment handler count: ${handlerName}, sessionId: ${sessionId}, systemMessageName: ${systemMessageName}`,\n    );\n    const session = await this.getSession(sessionId, systemMessageName);\n    if (!session.handlersCount[handlerName]) {\n      session.handlersCount[handlerName] = 0;\n    }\n    session.handlersCount[handlerName] += 1;\n    const sessionKey = this.getChatCompletionSessionKey(\n      sessionId,\n      systemMessageName,\n    );\n    await this.client.set(\n      sessionKey,\n      JSON.stringify(session),\n      'EX',\n      this.sessionTtl,\n    );\n  }\n\n  async save(session: Session): Promise<Session> {\n    l.info(\n      `Save session: ${session.sessionId}, systemMessageName: ${session.systemMessageName}`,\n    );\n    const existingSession = await this.getSession(\n      session.sessionId,\n      session.systemMessageName,\n    );\n\n    // fix redis frequency save by the same key issue\n    if (deepEqual(existingSession, session)) {\n      l.warn(\n        `sessionId ${session.sessionId}, systemMessageName: ${session.systemMessageName} - session not changed, skip save and return existing session`,\n      );\n      return existingSession;\n    }\n\n    existingSession.messages.length = 0;\n    session.messages.forEach((message) => {\n      existingSession.messages.push(message);\n      existingSession.lastMessageByRole[message.author] = message;\n    });\n\n    existingSession.ctx = session.ctx;\n    existingSession.updatedAt = getTimestamp();\n    existingSession.messageAccumulator = session.messageAccumulator;\n    existingSession.lastError = session.lastError;\n\n    const sessionKey = this.getChatCompletionSessionKey(\n      session.sessionId,\n      session.systemMessageName,\n    );\n\n    await this.client.set(\n      sessionKey,\n      JSON.stringify(existingSession),\n      'EX',\n      this.sessionTtl,\n    );\n\n    return this.getSession(session.sessionId, session.systemMessageName);\n  }\n\n  async getSession(\n    sessionId: string,\n    systemMessageName: string,\n  ): Promise<Session> {\n    try {\n      l.info(\n        `Get session: ${sessionId}, systemMessageName: ${systemMessageName}`,\n      );\n      const sessionKey = this.getChatCompletionSessionKey(\n        sessionId,\n        systemMessageName,\n      );\n      const sessionData = await this.client.get(sessionKey);\n      if (!sessionData) {\n        throw new Error(`Session ${sessionId} not found`);\n      }\n\n      const SessionData = JSON.parse(sessionData) as SessionProps;\n      const session = new Session(this, SessionData);\n\n      return session;\n    } catch (error) {\n      l.error(error);\n      throw error;\n    }\n  }\n}\n"]}