{"version":3,"file":"QueryByArrayOfInstance.js","sourceRoot":"","sources":["../../src/session/QueryByArrayOfInstance.ts"],"names":[],"mappings":"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","sourcesContent":["import { getLogger } from './../Logger';\n\nconst l = getLogger('ChatHistoryQueryEngine');\n\ntype QueryOperator<T> =\n  | { $eq?: T }\n  | { $ne?: T }\n  | { $gt?: T }\n  | { $gte?: T }\n  | { $lt?: T }\n  | { $lte?: T }\n  | { $in?: T[] }\n  | { $contains?: string }\n  | { $regex?: RegExp };\n\ntype Query<T> = {\n  [K in keyof T]?: T[K] extends (infer U)[]\n    ? QueryOperator<T[K]> | QueryOperator<U>[]\n    : QueryOperator<T[K]> | Query<T[K]>;\n};\n\ntype LogicalQuery<T> = {\n  $and?: FullQuery<T>[];\n  $or?: FullQuery<T>[];\n  $nor?: FullQuery<T>[];\n  $not?: FullQuery<T>[];\n};\n\ntype FullQuery<T> = Query<T> | LogicalQuery<T>;\n\nexport abstract class QueryByArrayOfObjects<T> extends Array<T> {\n  constructor(...items: T[]) {\n    super(...items);\n    l.info(`ChatHistoryQueryEngine initialization...`);\n  }\n\n  query(query: FullQuery<T>): T[] {\n    l.info(`query: ${JSON.stringify(query)}`);\n    return this.filter((item) => this.evaluate(item, query));\n  }\n\n  private evaluate(item: T, query: FullQuery<T>): boolean {\n    if (\n      '$and' in query ||\n      '$or' in query ||\n      '$nor' in query ||\n      '$not' in query\n    ) {\n      const operator = Object.keys(query)[0] as keyof LogicalQuery<T>;\n      const values = (query as LogicalQuery<T>)[operator];\n      if (!values) return true;\n      switch (operator) {\n        case '$and':\n          return values.every((value) => this.evaluate(item, value));\n        case '$or':\n          return values.some((value) => this.evaluate(item, value));\n        case '$nor':\n          return !values.some((value) => this.evaluate(item, value));\n        case '$not':\n          return !values.every((value) => this.evaluate(item, value));\n        default:\n          throw new Error(`Invalid operator: ${operator}`);\n      }\n    } else {\n      for (let key in query as Query<T>) {\n        const conditions = (query as Query<T>)[key] as\n          | QueryOperator<T[keyof T]>\n          | Query<T[keyof T]>;\n        const fieldValue = item[key as keyof T];\n        if (\n          '$eq' in conditions ||\n          '$ne' in conditions ||\n          '$gt' in conditions ||\n          '$gte' in conditions ||\n          '$lt' in conditions ||\n          '$lte' in conditions ||\n          '$in' in conditions ||\n          '$contains' in conditions ||\n          '$regex' in conditions\n        ) {\n          const opConditions = conditions as QueryOperator<T[keyof T]>;\n          for (let op in opConditions) {\n            const condition =\n              opConditions[op as keyof QueryOperator<T[keyof T]>];\n            switch (op) {\n              case '$eq':\n                if (fieldValue !== condition) return false;\n                break;\n              case '$ne':\n                if (fieldValue === condition) return false;\n                break;\n              case '$gt':\n                if ((fieldValue as any) <= (condition as any)) return false;\n                break;\n              case '$gte':\n                if ((fieldValue as any) < (condition as any)) return false;\n                break;\n              case '$lt':\n                if ((fieldValue as any) >= (condition as any)) return false;\n                break;\n              case '$lte':\n                if ((fieldValue as any) > (condition as any)) return false;\n                break;\n              case '$in':\n                if (!(condition as T[keyof T][]).includes(fieldValue))\n                  return false;\n                break;\n              case '$contains':\n                if (\n                  typeof fieldValue === 'string' &&\n                  fieldValue.indexOf(condition as string) === -1\n                )\n                  return false;\n                break;\n              case '$regex':\n                if (\n                  typeof fieldValue === 'string' &&\n                  !(condition as RegExp).test(fieldValue)\n                )\n                  return false;\n                break;\n              default:\n                throw new Error(`Invalid operator: ${op}`);\n            }\n          }\n        } else if (typeof fieldValue === 'object' && fieldValue !== null) {\n          if (!this.evaluate(fieldValue as any, conditions as FullQuery<any>))\n            return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // fix that prevent call empty constructor when use map, filter, etc.\n  static get [Symbol.species]() {\n    return Array;\n  }\n}\n"]}