{"version":3,"file":"LlmIoManager.js","sourceRoot":"","sources":["../src/LlmIoManager.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AsyncLLMInputMiddleware,\n  AsyncLLMOutputMiddleware,\n  ChatInputPayload,\n  LLMInputMiddlewares,\n  LLMOutputMiddlewares,\n  MiddlewareStatus,\n  OutputContext,\n} from './@types';\nimport { getLogger } from './Logger';\n\nconst l = getLogger('LlmIOManager');\n\nexport type InputMiddlewareContext = {\n  message: string;\n};\n\nexport class LlmIOManager {\n  private llmInputMiddlewareChain: LLMInputMiddlewares = new Map();\n  private llmOutputMiddlewareChain: LLMOutputMiddlewares = new Map();\n\n  constructor() {\n    l.info('LlmIOManager initialization...');\n  }\n\n  useInput(name: string, middleware: AsyncLLMInputMiddleware) {\n    if (this.llmInputMiddlewareChain.has(middleware.name)) {\n      throw new Error(\n        `A input middleware with the name \"${name}\" already exists.`,\n      );\n    }\n    l.info(`Registered input middleware with the name \"${name}\".`);\n    this.llmInputMiddlewareChain.set(name, middleware);\n  }\n\n  useOutput(name: string, middleware: AsyncLLMOutputMiddleware) {\n    if (this.llmOutputMiddlewareChain.has(middleware.name)) {\n      throw new Error(\n        `A output middleware with the name \"${name}\" already exists.`,\n      );\n    }\n    l.info(`Registered output middleware with the name \"${name}\".`);\n    this.llmOutputMiddlewareChain.set(name, middleware);\n  }\n\n  async executeInputMiddlewareChain(\n    inputContext: ChatInputPayload,\n  ): Promise<ChatInputPayload> {\n    if (this.llmInputMiddlewareChain.size === 0) {\n      return inputContext;\n    }\n    const { sessionId, systemMessageName } = inputContext;\n    l.info(\n      `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - Executing input middleware chain`,\n    );\n    let middlewaresIterator = this.llmInputMiddlewareChain.entries();\n    let currentMiddlewareEntry = middlewaresIterator.next();\n    let modifiedContext: ChatInputPayload = { ...inputContext };\n\n    try {\n      const next = async (\n        modifiedInputContext: ChatInputPayload,\n      ): Promise<void> => {\n        if (currentMiddlewareEntry.done) return;\n        let [name, middleware] = currentMiddlewareEntry.value;\n        currentMiddlewareEntry = middlewaresIterator.next();\n\n        try {\n          l.info(\n            `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - Executing middleware: ${name}...`,\n          );\n          // TODO: need refactor middleware. each middleware should return modified context to check type of context\n          await middleware(\n            modifiedInputContext,\n            (nextInputContext: ChatInputPayload) => {\n              modifiedContext = { ...nextInputContext };\n              return next(modifiedContext);\n            },\n          );\n        } catch (error) {\n          l.error(`Error occurred in middleware ${name}: ${error}`);\n          throw error;\n        }\n      };\n\n      await next(inputContext);\n    } catch (error) {\n      l.error(\n        `Error occurred while executing middleware chain by sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - ${error}`,\n      );\n    }\n\n    return modifiedContext;\n  }\n\n  async executeOutputMiddlewareChain(\n    outputContext: OutputContext,\n  ): Promise<[status: string, outputContext: OutputContext]> {\n    if (this.llmOutputMiddlewareChain.size === 0) {\n      return [MiddlewareStatus.CONTINUE, outputContext];\n    }\n\n    const { sessionId, systemMessageName } = outputContext.session;\n    l.info(\n      `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - Executing output middleware chain`,\n    );\n    let middlewaresIterator = this.llmOutputMiddlewareChain.entries();\n    let currentMiddlewareEntry = middlewaresIterator.next();\n    let modifiedContext: OutputContext = { ...outputContext };\n    const middlewareStatuses: { name: string; status: MiddlewareStatus }[] = [];\n\n    try {\n      const next = async (\n        modifiedOutputContext: OutputContext,\n      ): Promise<void> => {\n        if (currentMiddlewareEntry.done) return;\n        let [name, middleware] = currentMiddlewareEntry.value;\n        currentMiddlewareEntry = middlewaresIterator.next();\n\n        try {\n          l.info(\n            `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - Executing middleware: ${name}...`,\n          );\n          const { status, newOutputContext } = await middleware(\n            modifiedOutputContext,\n            (nextIOContext: OutputContext) => {\n              modifiedContext = { ...nextIOContext };\n              return next(modifiedContext);\n            },\n          );\n\n          middlewareStatuses.push({\n            name,\n            status: status || MiddlewareStatus.NOT_RETURNED,\n          });\n\n          if (\n            status === MiddlewareStatus.CALL_AGAIN ||\n            status === MiddlewareStatus.STOP\n          ) {\n            return;\n          } else if (newOutputContext && status === MiddlewareStatus.CONTINUE) {\n            return next(newOutputContext);\n          }\n        } catch (error) {\n          l.error(`Error occurred in middleware ${name}: ${error}`);\n          throw error;\n        }\n      };\n      await next(outputContext);\n    } catch (error) {\n      l.error(`Error occurred while executing middleware chain: ${error}`);\n    }\n\n    l.info(\n      `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - Middleware statuses: ${middlewareStatuses}`,\n    );\n    const isCallAgain = middlewareStatuses.some(\n      ({ status }) =>\n        status.includes(MiddlewareStatus.CALL_AGAIN) ||\n        status.includes(MiddlewareStatus.STOP),\n    );\n\n    modifiedContext.session.save();\n\n    if (isCallAgain) {\n      l.info(\n        `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - LLM Response handling will not be finished. Because one of Output Middlewares returned status: ${MiddlewareStatus.CALL_AGAIN} | ${MiddlewareStatus.STOP}, which means that the Output Middlewares chain will be executed again in the next iteration.`,\n      );\n      return [MiddlewareStatus.CALL_AGAIN, modifiedContext];\n    } else {\n      l.info(\n        `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - LLM Response successfully handled by Output Middlewares. and will will be passed to EventManager handlers.`,\n      );\n      return [MiddlewareStatus.CONTINUE, modifiedContext];\n    }\n  }\n}\n"]}