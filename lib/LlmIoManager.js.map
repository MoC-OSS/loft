{"version":3,"file":"LlmIoManager.js","names":["MiddlewareStatus","getLogger","l","LlmIOManager","llmInputMiddlewareChain","Map","llmOutputMiddlewareChain","constructor","info","useInput","name","middleware","has","Error","set","useOutput","executeInputMiddlewareChain","inputContext","size","sessionId","systemMessageName","middlewaresIterator","entries","currentMiddlewareEntry","next","modifiedContext","modifiedInputContext","done","value","nextInputContext","error","executeOutputMiddlewareChain","outputContext","CONTINUE","session","middlewareStatuses","modifiedOutputContext","status","newOutputContext","nextIOContext","push","NOT_RETURNED","CALL_AGAIN","STOP","isCallAgain","some","includes","save"],"sources":["../src/LlmIoManager.ts"],"sourcesContent":["import {\n  AsyncLLMInputMiddleware,\n  AsyncLLMOutputMiddleware,\n  ChatInputPayload,\n  LLMInputMiddlewares,\n  LLMOutputMiddlewares,\n  MiddlewareStatus,\n  OutputContext,\n} from './@types';\nimport { getLogger } from './Logger';\n\nconst l = getLogger('LlmIOManager');\n\nexport type InputMiddlewareContext = {\n  message: string;\n};\n\nexport class LlmIOManager {\n  private llmInputMiddlewareChain: LLMInputMiddlewares = new Map();\n  private llmOutputMiddlewareChain: LLMOutputMiddlewares = new Map();\n\n  constructor() {\n    l.info('LlmIOManager initialization...');\n  }\n\n  useInput(name: string, middleware: AsyncLLMInputMiddleware) {\n    if (this.llmInputMiddlewareChain.has(middleware.name)) {\n      throw new Error(\n        `A input middleware with the name \"${name}\" already exists.`,\n      );\n    }\n    l.info(`Registered input middleware with the name \"${name}\".`);\n    this.llmInputMiddlewareChain.set(name, middleware);\n  }\n\n  useOutput(name: string, middleware: AsyncLLMOutputMiddleware) {\n    if (this.llmOutputMiddlewareChain.has(middleware.name)) {\n      throw new Error(\n        `A output middleware with the name \"${name}\" already exists.`,\n      );\n    }\n    l.info(`Registered output middleware with the name \"${name}\".`);\n    this.llmOutputMiddlewareChain.set(name, middleware);\n  }\n\n  async executeInputMiddlewareChain(\n    inputContext: ChatInputPayload,\n  ): Promise<ChatInputPayload> {\n    if (this.llmInputMiddlewareChain.size === 0) {\n      return inputContext;\n    }\n    const { sessionId, systemMessageName } = inputContext;\n    l.info(\n      `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - Executing input middleware chain`,\n    );\n    let middlewaresIterator = this.llmInputMiddlewareChain.entries();\n    let currentMiddlewareEntry = middlewaresIterator.next();\n    let modifiedContext: ChatInputPayload = { ...inputContext };\n\n    try {\n      const next = async (\n        modifiedInputContext: ChatInputPayload,\n      ): Promise<void> => {\n        if (currentMiddlewareEntry.done) return;\n        let [name, middleware] = currentMiddlewareEntry.value;\n        currentMiddlewareEntry = middlewaresIterator.next();\n\n        try {\n          l.info(\n            `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - Executing middleware: ${name}...`,\n          );\n          // TODO: need refactor middleware. each middleware should return modified context to check type of context\n          await middleware(\n            modifiedInputContext,\n            (nextInputContext: ChatInputPayload) => {\n              modifiedContext = { ...nextInputContext };\n              return next(modifiedContext);\n            },\n          );\n        } catch (error) {\n          l.error(`Error occurred in middleware ${name}: ${error}`);\n          throw error;\n        }\n      };\n\n      await next(inputContext);\n    } catch (error) {\n      l.error(\n        `Error occurred while executing middleware chain by sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - ${error}`,\n      );\n    }\n\n    return modifiedContext;\n  }\n\n  async executeOutputMiddlewareChain(\n    outputContext: OutputContext,\n  ): Promise<[status: string, outputContext: OutputContext]> {\n    if (this.llmOutputMiddlewareChain.size === 0) {\n      return [MiddlewareStatus.CONTINUE, outputContext];\n    }\n\n    const { sessionId, systemMessageName } = outputContext.session;\n    l.info(\n      `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - Executing output middleware chain`,\n    );\n    let middlewaresIterator = this.llmOutputMiddlewareChain.entries();\n    let currentMiddlewareEntry = middlewaresIterator.next();\n    let modifiedContext: OutputContext = { ...outputContext };\n    const middlewareStatuses: { name: string; status: MiddlewareStatus }[] = [];\n\n    try {\n      const next = async (\n        modifiedOutputContext: OutputContext,\n      ): Promise<void> => {\n        if (currentMiddlewareEntry.done) return;\n        let [name, middleware] = currentMiddlewareEntry.value;\n        currentMiddlewareEntry = middlewaresIterator.next();\n\n        try {\n          l.info(\n            `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - Executing middleware: ${name}...`,\n          );\n          const { status, newOutputContext } = await middleware(\n            modifiedOutputContext,\n            (nextIOContext: OutputContext) => {\n              modifiedContext = { ...nextIOContext };\n              return next(modifiedContext);\n            },\n          );\n\n          middlewareStatuses.push({\n            name,\n            status: status || MiddlewareStatus.NOT_RETURNED,\n          });\n\n          if (\n            status === MiddlewareStatus.CALL_AGAIN ||\n            status === MiddlewareStatus.STOP\n          ) {\n            return;\n          } else if (newOutputContext && status === MiddlewareStatus.CONTINUE) {\n            return next(newOutputContext);\n          }\n        } catch (error) {\n          l.error(`Error occurred in middleware ${name}: ${error}`);\n          throw error;\n        }\n      };\n      await next(outputContext);\n    } catch (error) {\n      l.error(`Error occurred while executing middleware chain: ${error}`);\n    }\n\n    l.info(\n      `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - Middleware statuses: ${middlewareStatuses}`,\n    );\n    const isCallAgain = middlewareStatuses.some(\n      ({ status }) =>\n        status.includes(MiddlewareStatus.CALL_AGAIN) ||\n        status.includes(MiddlewareStatus.STOP),\n    );\n\n    modifiedContext.session.save();\n\n    if (isCallAgain) {\n      l.info(\n        `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - LLM Response handling will not be finished. Because one of Output Middlewares returned status: ${MiddlewareStatus.CALL_AGAIN} | ${MiddlewareStatus.STOP}, which means that the Output Middlewares chain will be executed again in the next iteration.`,\n      );\n      return [MiddlewareStatus.CALL_AGAIN, modifiedContext];\n    } else {\n      l.info(\n        `sessionId: ${sessionId}, systemMessageName: ${systemMessageName} - LLM Response successfully handled by Output Middlewares. and will will be passed to EventManager handlers.`,\n      );\n      return [MiddlewareStatus.CONTINUE, modifiedContext];\n    }\n  }\n}\n"],"mappings":"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"}