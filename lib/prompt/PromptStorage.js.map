{"version":3,"file":"PromptStorage.js","names":["getLogger","l","PromptStorage","constructor","client","syncPrompts","data","info","existingNames","Set","pipeline","prompts","forEach","p","set","name","JSON","stringify","add","storedNames","keys","storedName","has","del","exec","getPromptByName","get","undefined","parse","error","updatePromptByName","prompt","deletePromptByName"],"sources":["../../src/prompt/PromptStorage.ts"],"sourcesContent":["import { Redis, Cluster } from 'ioredis';\nimport { PromptType, PromptsFileType } from '../schema/PromptSchema';\nimport { getLogger } from './../Logger';\n\nconst l = getLogger('PromptStorage');\n\nexport class PromptStorage {\n  private client: Redis | Cluster;\n\n  constructor(client: Redis | Cluster) {\n    this.client = client;\n  }\n\n  public async syncPrompts(data: PromptsFileType): Promise<void> {\n    l.info('syncing prompts to redis...');\n    const existingNames: Set<string> = new Set();\n    const pipeline = this.client.pipeline();\n\n    // Iterate through the ingested Prompts and store them in Redis\n    data.prompts.forEach((p) => {\n      pipeline.set(p.name, JSON.stringify(p));\n      existingNames.add(p.name);\n    });\n\n    // Retrieve the existing names from Redis\n    const storedNames = await this.client.keys('*');\n\n    // Find and remove the Prompts with names that are missing in the received Prompts\n    storedNames.forEach((storedName) => {\n      if (!existingNames.has(storedName)) {\n        pipeline.del(storedName);\n      }\n    });\n\n    await pipeline.exec();\n  }\n\n  public async getPromptByName(name: string): Promise<PromptType | null> {\n    l.info(`getting prompt: ${name} from redis...`);\n    try {\n      const data = await this.client.get(name);\n      if (data === null || data === undefined) return null;\n\n      return JSON.parse(data ?? '');\n    } catch (error) {\n      l.error(error);\n      throw error;\n    }\n  }\n\n  public async updatePromptByName(name: string, prompt: string): Promise<void> {\n    l.info(`updating prompt: ${name} in redis...`);\n    await this.client.set(name, prompt);\n  }\n\n  public async deletePromptByName(name: string): Promise<void> {\n    l.info(`deleting prompt: ${name} from redis...`);\n    await this.client.del(name);\n  }\n}\n"],"mappings":"AAEA,OAASA,SAAS,KAAQ,aAAa,CAEvC,KAAM,CAAAC,CAAC,CAAGD,SAAS,CAAC,eAAe,CAAC,CAEpC,MAAO,MAAM,CAAAE,aAAc,CAGzBC,WAAWA,CAACC,MAAuB,CAAE,CACnC,IAAI,CAACA,MAAM,CAAGA,MAChB,CAEA,KAAa,CAAAC,WAAWA,CAACC,IAAqB,CAAiB,CAC7DL,CAAC,CAACM,IAAI,CAAC,6BAA6B,CAAC,CACrC,KAAM,CAAAC,aAA0B,CAAG,GAAI,CAAAC,GAAK,CAC5C,KAAM,CAAAC,QAAQ,CAAG,IAAI,CAACN,MAAM,CAACM,QAAQ,CAAC,CAAC,CAGvCJ,IAAI,CAACK,OAAO,CAACC,OAAO,CAAEC,CAAC,EAAK,CAC1BH,QAAQ,CAACI,GAAG,CAACD,CAAC,CAACE,IAAI,CAAEC,IAAI,CAACC,SAAS,CAACJ,CAAC,CAAC,CAAC,CACvCL,aAAa,CAACU,GAAG,CAACL,CAAC,CAACE,IAAI,CAC1B,CAAC,CAAC,CAGF,KAAM,CAAAI,WAAW,CAAG,KAAM,KAAI,CAACf,MAAM,CAACgB,IAAI,CAAC,GAAG,CAAC,CAG/CD,WAAW,CAACP,OAAO,CAAES,UAAU,EAAK,CAClC,GAAI,CAACb,aAAa,CAACc,GAAG,CAACD,UAAU,CAAC,CAAE,CAClCX,QAAQ,CAACa,GAAG,CAACF,UAAU,CACzB,CACF,CAAC,CAAC,CAEF,KAAM,CAAAX,QAAQ,CAACc,IAAI,CAAC,CACtB,CAEA,KAAa,CAAAC,eAAeA,CAACV,IAAY,CAA8B,CACrEd,CAAC,CAACM,IAAI,CAAE,mBAAkBQ,IAAK,gBAAe,CAAC,CAC/C,GAAI,CACF,KAAM,CAAAT,IAAI,CAAG,KAAM,KAAI,CAACF,MAAM,CAACsB,GAAG,CAACX,IAAI,CAAC,CACxC,GAAIT,IAAI,GAAK,IAAI,EAAIA,IAAI,GAAKqB,SAAS,CAAE,MAAO,KAAI,CAEpD,MAAO,CAAAX,IAAI,CAACY,KAAK,CAACtB,IAAI,EAAI,EAAE,CAC9B,CAAE,MAAOuB,KAAK,CAAE,CACd5B,CAAC,CAAC4B,KAAK,CAACA,KAAK,CAAC,CACd,KAAM,CAAAA,KACR,CACF,CAEA,KAAa,CAAAC,kBAAkBA,CAACf,IAAY,CAAEgB,MAAc,CAAiB,CAC3E9B,CAAC,CAACM,IAAI,CAAE,oBAAmBQ,IAAK,cAAa,CAAC,CAC9C,KAAM,KAAI,CAACX,MAAM,CAACU,GAAG,CAACC,IAAI,CAAEgB,MAAM,CACpC,CAEA,KAAa,CAAAC,kBAAkBA,CAACjB,IAAY,CAAiB,CAC3Dd,CAAC,CAACM,IAAI,CAAE,oBAAmBQ,IAAK,gBAAe,CAAC,CAChD,KAAM,KAAI,CAACX,MAAM,CAACmB,GAAG,CAACR,IAAI,CAC5B,CACF"}