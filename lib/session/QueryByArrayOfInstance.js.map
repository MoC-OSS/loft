{"version":3,"file":"QueryByArrayOfInstance.js","names":["getLogger","l","QueryByArrayOfObjects","Array","constructor","items","info","query","JSON","stringify","filter","item","evaluate","operator","Object","keys","values","every","value","some","Error","key","conditions","fieldValue","opConditions","op","condition","includes","indexOf","test","Symbol","species"],"sources":["../../src/session/QueryByArrayOfInstance.ts"],"sourcesContent":["import { getLogger } from './../Logger';\n\nconst l = getLogger('ChatHistoryQueryEngine');\n\ntype QueryOperator<T> =\n  | { $eq?: T }\n  | { $ne?: T }\n  | { $gt?: T }\n  | { $gte?: T }\n  | { $lt?: T }\n  | { $lte?: T }\n  | { $in?: T[] }\n  | { $contains?: string }\n  | { $regex?: RegExp };\n\ntype Query<T> = {\n  [K in keyof T]?: T[K] extends (infer U)[]\n    ? QueryOperator<T[K]> | QueryOperator<U>[]\n    : QueryOperator<T[K]> | Query<T[K]>;\n};\n\ntype LogicalQuery<T> = {\n  $and?: FullQuery<T>[];\n  $or?: FullQuery<T>[];\n  $nor?: FullQuery<T>[];\n  $not?: FullQuery<T>[];\n};\n\ntype FullQuery<T> = Query<T> | LogicalQuery<T>;\n\nexport abstract class QueryByArrayOfObjects<T> extends Array<T> {\n  constructor(...items: T[]) {\n    super(...items);\n    l.info(`ChatHistoryQueryEngine initialization...`);\n  }\n\n  query(query: FullQuery<T>): T[] {\n    l.info(`query: ${JSON.stringify(query)}`);\n    return this.filter((item) => this.evaluate(item, query));\n  }\n\n  private evaluate(item: T, query: FullQuery<T>): boolean {\n    if (\n      '$and' in query ||\n      '$or' in query ||\n      '$nor' in query ||\n      '$not' in query\n    ) {\n      const operator = Object.keys(query)[0] as keyof LogicalQuery<T>;\n      const values = (query as LogicalQuery<T>)[operator];\n      if (!values) return true;\n      switch (operator) {\n        case '$and':\n          return values.every((value) => this.evaluate(item, value));\n        case '$or':\n          return values.some((value) => this.evaluate(item, value));\n        case '$nor':\n          return !values.some((value) => this.evaluate(item, value));\n        case '$not':\n          return !values.every((value) => this.evaluate(item, value));\n        default:\n          throw new Error(`Invalid operator: ${operator}`);\n      }\n    } else {\n      for (let key in query as Query<T>) {\n        const conditions = (query as Query<T>)[key] as\n          | QueryOperator<T[keyof T]>\n          | Query<T[keyof T]>;\n        const fieldValue = item[key as keyof T];\n        if (\n          '$eq' in conditions ||\n          '$ne' in conditions ||\n          '$gt' in conditions ||\n          '$gte' in conditions ||\n          '$lt' in conditions ||\n          '$lte' in conditions ||\n          '$in' in conditions ||\n          '$contains' in conditions ||\n          '$regex' in conditions\n        ) {\n          const opConditions = conditions as QueryOperator<T[keyof T]>;\n          for (let op in opConditions) {\n            const condition =\n              opConditions[op as keyof QueryOperator<T[keyof T]>];\n            switch (op) {\n              case '$eq':\n                if (fieldValue !== condition) return false;\n                break;\n              case '$ne':\n                if (fieldValue === condition) return false;\n                break;\n              case '$gt':\n                if ((fieldValue as any) <= (condition as any)) return false;\n                break;\n              case '$gte':\n                if ((fieldValue as any) < (condition as any)) return false;\n                break;\n              case '$lt':\n                if ((fieldValue as any) >= (condition as any)) return false;\n                break;\n              case '$lte':\n                if ((fieldValue as any) > (condition as any)) return false;\n                break;\n              case '$in':\n                if (!(condition as T[keyof T][]).includes(fieldValue))\n                  return false;\n                break;\n              case '$contains':\n                if (\n                  typeof fieldValue === 'string' &&\n                  fieldValue.indexOf(condition as string) === -1\n                )\n                  return false;\n                break;\n              case '$regex':\n                if (\n                  typeof fieldValue === 'string' &&\n                  !(condition as RegExp).test(fieldValue)\n                )\n                  return false;\n                break;\n              default:\n                throw new Error(`Invalid operator: ${op}`);\n            }\n          }\n        } else if (typeof fieldValue === 'object' && fieldValue !== null) {\n          if (!this.evaluate(fieldValue as any, conditions as FullQuery<any>))\n            return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // fix that prevent call empty constructor when use map, filter, etc.\n  static get [Symbol.species]() {\n    return Array;\n  }\n}\n"],"mappings":"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"}